# 浏览器缓存机制

首先，浏览器的缓存方式主要有以下四种：

1. `Service Worker`
2. `Memory Cache`
3. `Disk Cache`
4. `Push Cache`

## `Service Worker`

`Service Worker` 本质上是一个拦截者。它可以细致的控制每一件事情。最常用于离线状态下，控制页面的显示。它会拦截并修改网络请求，细粒度的控制缓存资源。也正是因为其拦截的本质，只能在 `HTTPS` 协议下工作。

当在当前域注册了 `Service Worker` 之后，访问这个页面时，会自动激活。其会拦截请求，查询是否存在缓存，存在则使用缓存，否则请求数据。并且，最终无论从哪里获取到的数据，浏览器都会显示是从 `Service Worker` 获取的数据。

![image](http://udh.oss-cn-hangzhou.aliyuncs.com/a874e9bd-70ec-4027-9f79-4864bc9b14d51607072106225WX202012041654392x.png)

## `Memory Cache`

内存缓存。通常会缓存体积较小的图片、样式、脚本等资源。

读取内存中的资源会非常迅速。但是其持续性很短。会随着进程的释放和释放。计算机需要精确的使用内存，保证计算机的流畅运行。所以一旦我们关闭标签页，内存缓存将被释放。

内存缓存对应一种常见的性能优化指令 `preloader` . 例如 `<link rel="prefetch">`.

内存缓存因为其时效性很短，所以不会去在意 `Cache-Control` 的值。

又由于其占用内存使用，其不仅只对 `URL` 做匹配，还会对该资源的 `content-type` 和 `cors` 等属性做校验。

其特性就是，需要经过多重验证，判断你就是我要使用缓存的那个资源，一旦判断正确，就算你说不让我使用，我也不听～

## `Disk Cache`

存储于硬盘中的缓存。读取速度较慢。绝大部分的缓存都来源这里。

根据 HTTP 缓存机制，去使用缓存，存储缓存/更新缓存。

关于 `HTTP缓存机制`，请看下文解读。

## `Push Cache`

当以上三种缓存都没有被命中的时候，才会使用 `Push Cache`。其是 `HTTP/2` 中新增都内容。只会在会话(`session`)中存在，一旦会话结束就会被释放。

---

以上便是浏览器常见的缓存方式，其中 `Memory Cache` 和 `Disk Cache` 最常见。

那浏览器如何判断是否需要使用缓存，是否需要缓存资源，是否需要更新缓存呢？

当我们第一次请求资源时，其缓存过程如下：

1. 浏览器发起 `HTTP` 请求。
2. 在浏览器缓存中查找是否有该缓存的缓存标识。（第一次请求该资源，否）
3. 发起 `HTTP` 请求到服务器。
4. 服务器返回请求结果和缓存规则给浏览器。
5. 浏览器按照缓存规则将资源缓存。

以后再次请求该资源时，浏览器将根据缓存中的缓存标识判断是否直接使用缓存。

我们将直接使用缓存，不与服务器进行通信的方式叫做 `强缓存`。反之，与服务器通信之后，再确实使用缓存的方式叫做 `协商缓存` 。

其都是根据服务器的 `response header` 中的缓存标识做判断。

## 强缓存

与强缓存有关的 `response header` 字段，常见以下两种：

### `Expires`

`HTTP/1.0` 的产物。受限于本地时间。如果修改本地时间，会影响缓存的读取判断。

`Expires: Wed, 21 Oct 2015 07:28:00 GMT`

一个 `<http-date>`。表示过期时间。在此时间之后，缓存过期，需要重新发起 `HTTP请求`.

如果同时存在 `cache-control` 的 `max-age或者s-max-age` 和 `expires` ,那么 `expires` 会被忽略。

### `Cache-Control`

`HTTP/1.1` 新增产物。

请求头和响应头都可以携带该指令。

> 可缓存性

**`public`**

该指令表明：该资源可以被任何对象缓存（客户端，代理服务器等等）。

**`private`**

该指令表明：该资源只能被单个用户缓存（代理服务器不能缓存它）。

**`no-cache`**

该指令表明：该资源必须进行 `协商缓存` 。即使它没有过期。

**`no-store`**

该指令表明：该资源禁止被缓存。

> 到期

**`max-age`**

`max-age: 300`.单位秒。表示在请求（expires 是以响应时间为参照）时间后的 5 分钟内，再次请求这个资源，会命中强缓存。

**`s-maxage`**

`s-maxage: 300`.单位秒。代理服务器缓存。如`cdn缓存`。表明在 5 分钟内，就算 `cdn` 上的该资源进行了更新，浏览器也不会重新请求该 `cdn` 上的该资源。`s-maxage` 会覆盖 `max-age`。

**`max-stale`**

`max-stale`,表明客户端愿意接受一个过期的资源。

`max-stale: 300`,单位秒。表明，可以接受过期资源，但是必须在 5 分钟之内返回给我。

**`min-fresh`**

`min-fresh: 300`,单位秒。表明愿意接受一个在 5 分钟内是最新状态的资源。

## 协商缓存

当强缓存命中失败时，就会与服务器进行协商，看是否能够继续使用缓存。

主要判断方式有两种：

### `Last-Modified` 和 `If-Modified-Since`

其判断流程如下：

1. 浏览器第一次请求该资源，服务器返回该资源的 `Last-Modified` 时间。
2. 浏览器缓存该资源，并记录该资源的 `Last-Modified` 时间。
3. 再次请求该资源，浏览器请求头会携带 `If-Modified-Since`,其值就是上次存储的 `Last-Modified` 的值。
4. 服务器在获取到 `If-Modified-Since` 的值后，会和该资源现在的 `Last-Modified` 时间做比较。

如果资源过期，返回 `200`。告知浏览器需要重新发起 `HTTP请求`。反之返回 `304`。告知浏览器可以使用本地缓存。

其是 `HTTP/1.0` 中的判断机制。由于以秒为单位，并且依赖于本地时间。如果文件在不可感知的时间内被修改，或者在本地被打开，将会影响是否缓存命中的判断。

### `Etag` 和 `If-None-Match`

其判断流程类似上面，如下：

1. 浏览器第一次请求该资源，服务器返回该资源的 `Etag` 字符串。
2. 浏览器缓存该资源，并记录该资源的 `Etag` 。
3. 再次请求该资源时，浏览器请求头会携带 `If-None-Match`,其值就是上次存储的 `Etag` 的值。
4. 服务器在获取到 `If-None-Match` 的值后，会于该资源当前的 `Etag` 做比较。

如果资源有变化，服务器会立刻更改该资源的 `Etag` 值。

如果资源过期，返回 `200`。告知浏览器需要重新发起 `HTTP请求`。反之返回 `304`。告知浏览器可以使用本地缓存。

### 二者比较

在精度上，后者优于前者。

在性能上，后者逊于前者。

在优先级上，后者优于前者。

---

我的另一篇文章[从键入 URL 到显示页面发生了什么](https://github.com/1282772905/Notes/blob/master/http/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2.md)，详细分析了对比浏览器缓存的过程。
