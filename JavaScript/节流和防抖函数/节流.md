`防抖`：你尽管触发，等你什么时候不触发了，我在`n`秒之后再执行函数。

`节流`：持续触发事件，每间隔`n`秒，我执行一次函数。

有两种方法实现`节流`

#### 时间戳

利用当前时间戳减去上次函数执行时的时间戳，如果大于`n`就再次执行函数。

代码如下：

```html
<div class="content"></div>
```

```js
const content = document.querySelector('content');

const myFun = function(e) {
    console.log(this, e);
};

const throttle = (fun, delay = 1000) => {
    let pre = 0;
    return function(...args) {
        let now = Date.now();
        if (now - pre > delay) {
            fun.apply(this, args);
            pre = now;
        }
    };
};

content.addEventListener('mousemove', throttle(myFun));
```

一开始的时间戳设置为0，所以一开始就会执行一次函数。后面每间隔1s执行一次函数，当不再触发事件时，立即停止。

#### 定时器
一开始`timer`为`null`，进入函数，创建一个定时器，在`delay`秒后执行函数。该函数除了执行目标函数外，同时又将`timer`设置成了`null`,所以`delay`秒后，又会再执行一次函数。

代码如下：

```js
const throttle = (fun, delay = 1000) => {
    let timer = null;
    return function(...args) {
        if (!timer) {
            timer = setTimeout(() => {
                fun.apply(this, args);
                timer = null;
            }, delay);
        }
    };
};
```

一开始并不会执行函数，等到`delay`秒后，执行第一次。停止触发事件，最后还是会触发一次，因为一个定时器已经存在了

#### 两种方法合并

如果我想一开始触发，结束后也会再触发一次呢？

代码如下：

```js
const throttle = (fun, delay = 1000) => {
    let pre = 0;
    let timer = null;
    return function(...args) {
        let now = Date.now();
        let remain = delay - (now - pre);
        if (remain <= 0 || remain > delay) {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            fun.apply(this, args);
            pre = now;
        } else if (!timer) {
            timer = setTimeout(() => {
                fun.apply(this, args);
                pre = Date.now();
                timer = null;
            }, remain);
        }
    }
};
```