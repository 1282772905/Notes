类似鼠标移动,输入文字等高频率触发事件的情况，如果执行的是一个很复杂的函数，例如`ajax`请求，那么移动一次鼠标，可能会请求一百次接口，导致页面卡顿

#### 防抖

> 防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!

以下是我理解防抖的心历路程

首先是没有防抖，看下面一段代码：

```html
<div class="content"></div>
```

```js
const content = document.querySelector('content');

const myFun = () => {
    console.log('我被执行了');
};
content.addEventListener('mousemove', myFun);
```

以上没有做防抖处理。结果是移动鼠标，会打印出非常多的`我被执行了`

然后我根据网上资料，自己写了一个简单的防抖处理：
```js
const content = document.querySelector('content');

const myFun = () => {
    console.log('我被执行了');
};

const debounce = (fun, delay = 50) => {
    let timer = null;
    return () => {
        clearTimeout(timer);
        timer = setTimeout(fun, delay);
    };
};
content.addEventListener('mousemove', debounce(myFun));
```

貌似效果不错，没有什么问题。

接着看网上资料，说到`this`的问题

> 如果我们在`myFun`中`console.log(this)`,不使用防抖的话，打印出来的应该是`<div class="content"></div>`,但是用了防抖之后，打印出来的是`window`.

按照网上解决方法，使用`fun.apply(this)`，把当前作用域的`this`赋值给`myFun`中的`this`.

所以有了我的如下代码

```js
const content = document.querySelector('content');

const myFun = () => {
    console.log(this);
};

const debounce = (fun, delay = 50) => {
    let timer = null;
    return () => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fun.apply(this);
        }, delay);
    };
};
content.addEventListener('mousemove', debounce(myFun));
```

本以为会打印出`<div class="content"></div>`,结果还是打印出了`window`.

查原因，原来是对`箭头函数`和`this`的理解又忘记了。

> 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。-es6箭头函数

上面的代码，其实就是将`鼠标移动`时执行的`myfun`函数，换成了`debounce`返回的`箭头函数`。也就是，我将`箭头函数`的`this`赋值给了`myfun`,而，箭头函数本身是没有`this`的，往上一层看，结果`debounce`也是箭头函数，所以最终，这个`this`指向了`window`.而我的`myFun`也是写的箭头函数，里面的`this`本来就是指向`window`，就算调用它的是`content`也无济于事。

所以，再有了下面的代码：

```js
const content = document.querySelector('content');

const myFun = function() {
    console.log(this);
};

const debounce = (fun, delay = 50) => {
    let timer = null;
    return function() {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fun.apply(this);
        }, delay);
    };
};
content.addEventListener('mousemove', debounce(myFun));
```

打印出了`<div class="content"></div>`

接着看网上的资料，说到`event`,`console.log(e)`应该要打印出`Mousemove`

所以，代码如下：

```js
const content = document.querySelector('content');

const myFun = function(e) {
    console.log(this, e);
};

const debounce = (fun, delay = 50) => {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fun.apply(this, args);
        }, delay);
    };
};
content.addEventListener('mousemove', debounce(myFun));
```

关于`...args`参考[rest参数](http://es6.ruanyifeng.com/#docs/function)

接着看网上资料，提到，不想每次事件触发后等n秒才执行函数，而是想做成一个开关，可以控制是否要这样。

代码如下了：

```js
const content = document.querySelector('.content');

const myFun = function(e) {
    console.log(this, e);
};

const debounce =  (fun, wait = 500, immediate) => {
    let timer = null;
    console.log('ddd');
    return function(...args) {
        if (timer) {
            clearTimeout(timer);
        }
        if (immediate) {
            let callNomw = !timer;
            timer = setTimeout(() => {
                timer = null;
            }, wait);
            if (callNomw) {
                fun.apply(this, args);
            }
        } else {
            timer = setTimeout(() => {
                fun.apply(this, args);
            }, wait);
        }
    };
};
content.addEventListener('mousemove', debounce(myFun, 5000, true));
```

至此，防抖函数完成，撒花～